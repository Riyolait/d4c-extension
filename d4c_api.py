# -*- coding: utf-8 -*-
"""
/***************************************************************************
 d4cAPI
                                 A QGIS plugin
 Using d4c api to manipulate ckan data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-09-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by MSE @ BPM-conseil
        email                : matthieu.serek@bpm-conseil.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt, QLocale
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QApplication, QStyle, QMainWindow
from qgis.core import QgsVectorLayer, QgsProject
from PyQt5 import QtWidgets, QtGui, QtCore


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .d4c_api_dialog import d4cAPIDialog
from .d4c_api_dialog_logins import Ui_LoginsWindow
from .d4c_api_dialog_export import Ui_d4cAPIDialogExport
from .d4c_api_dialog_add_dataset import Ui_Dialog
from .d4c_api_dialog_plugininfos import Ui_pluginInfos
from .d4c_api_dialog_infos import Ui_showInfos
from .d4c_api_dialog_searchdataset import Ui_searchDataset
import os
import requests
import json
import subprocess

import importlib

try:
    importlib.import_module('cryptography')
except ImportError:
    import pip
    pip.main(['install', 'cryptography'])

# Importez tqdm après avoir vérifié son installation
from cryptography.fernet import Fernet

class TableWindow(QMainWindow):
    def __init__(self, parent=None):
        super(TableWindow, self).__init__(parent)
        self.setWindowTitle("Tableau")
        self.setGeometry(300, 300, 500, 400)

        self.table = QtWidgets.QTableWidget(self)
        self.setCentralWidget(self.table)

        

class d4cAPI:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        self.translator = QTranslator()
        self.lang = None
        # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')
            
        # Chargez les sessions existantes depuis le fichier JSON
        destination_folder = os.path.expanduser('~/.d4cplugin')  # Modifier le chemin selon vos besoins
        json_file_path = os.path.join(destination_folder, 'logs.json')
        
        if not(os.path.exists(json_file_path)):
            data = {
                "last_session": {
                    "sessions": []
                },
                "lang": "fr"
            }
                    # Enregistrez les données mises à jour dans le fichier JSON
            with open(json_file_path, 'w') as json_file:
                json.dump(data, json_file, indent=4)
        else:
            with open(json_file_path, 'r') as json_file:
                data = json.load(json_file)
                self.lang = data['lang']
        
        self.loadTranslation(self.lang)  # Charge la traduction française par défaut
        if self.lang == 'fr':
            self.locale = QLocale(QLocale.French, QLocale.France)
        else:
            self.locale = QLocale(QLocale.English, QLocale.UnitedKingdom)
        QLocale.setDefault(self.locale)
        

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&D4C Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.sit = None
        self.usr = None
        self.pwd = None
        self.ui = None # Logins window
        self.ui2 = None # Export window
        self.resourceDict = {}
        self.listExistingResourceById = {}
        self.selectedDataId = None
        self.selectedDataOrg = None
        self.selectedDataPrivate = None
        self.csv_icon = None
        self.geojson_icon = None
        self.json_icon = None
        self.zip_icon = None
        self.key = None
        self.fernet = None
        self.isDelete = False
        self.currentDataset_id = None
        self.isLoadedSite = False

        self.data_title = None
        self.data_name = None
        self.data_author = None
        self.data_org = None
        self.data_license = None
        self.data_private = None
        self.data_url = None

        self.backofficeurl = None
        self.isAlldatasetsLoaded = False
        self.Alldatasetlist = []

        self.tableWidget = None

    def loadTranslation(self, locale):
        locale_path = os.path.join(
        self.plugin_dir,
        'i18n',
        f'd4c_api_{locale}.qm')

        if os.path.exists(locale_path):
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('d4cAPI', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        whats_this = self.tr(u'Test')
        status_tip = self.tr(u'Test')

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/d4c_api/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Data4Citizen extension'),
            callback=self.run,
            status_tip=self.tr(u'Data4Citizen extension'),
            whats_this=self.tr(u'Data4Citizen extension'),
            parent=self.iface.mainWindow())
        self.iface.registerMainWindowAction(self.actions[-1], "this extension connects to a Data4Citizen/Ckan platform and allows to manipulate its datasets")
        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&D4C Plugin'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""
        if self.first_start:
            self.first_start = False
            self.dlg = d4cAPIDialog()
            self.setupIcons()
            self.disableButtons()
            self.disableSearchButtons()
            self.read()
            self.dlg.ExecUrlApi.clicked.connect(self.getD4Cdatasets)
            self.dlg.pushWindowlogin.clicked.connect(self.openLoginsWindow)
            self.dlg.pushImportresource.clicked.connect(self.importResource)
            self.dlg.resourcesList.itemDoubleClicked.connect(self.importResource)
            self.dlg.pushExportAsNewresource.clicked.connect(self.exportAsNewResource)
            self.dlg.pushEmptyCache.clicked.connect(self.emptyCache)
            self.dlg.pushRefresh.clicked.connect(self.showExportableLayers)
            self.dlg.pushExit.clicked.connect(self.closePlugin)
            self.dlg.pushExportAsExistingresource.clicked.connect(self.showExistingResources)
            self.dlg.pushHistory.clicked.connect(self.loadPreviousSession)
            self.dlg.historyList.itemDoubleClicked.connect(self.loadPreviousSession)
            self.dlg.pushNewdataset.clicked.connect(self.openAddDatasetWindow)
            self.dlg.pushDeleteResource.clicked.connect(self.deleteResource)
            self.dlg.pushDeletedataset.clicked.connect(self.deleteDataset)
            self.dlg.pushInfos.clicked.connect(self.showInfoWindow)
            self.dlg.pushOpenFiledirectory.clicked.connect(self.openResourceFile)
            self.dlg.pushLoadHistoryfile.clicked.connect(self.openResourcefromFile)
            self.dlg.filesList.itemDoubleClicked.connect(self.openResourcefromFile)
            self.dlg.pushChangedataset.clicked.connect(self.getD4Cdatasets)
            self.dlg.siteField.textChanged.connect(self.turnOffAllDatasetLoaded)
            self.dlg.pushDisplayAllDatasets.clicked.connect(self.openAllDatasets)
            self.dlg.historyList.itemSelectionChanged.connect(self.updateHistoryPush)
            self.dlg.filesList.itemSelectionChanged.connect(self.updateFilesPush)
            self.dlg.pushDisplayAllDatasets2.clicked.connect(self.openAllDatasets)
            self.dlg.checkPrevisu.stateChanged.connect(self.showPrevisu)
            self.dlg.resourcesList.itemSelectionChanged.connect(self.updatePrevisu)
            self.dlg.pushOpenTableWindow.clicked.connect(self.openTableWindow)
            self.dlg.pushAbout.clicked.connect(self.openAbout)
            self.dlg.pushHelp.clicked.connect(self.openHelp)
            if self.lang == 'fr':
                self.dlg.languageBox.setCurrentIndex(0)
            else:
                self.dlg.languageBox.setCurrentIndex(1)
            self.dlg.languageBox.currentIndexChanged.connect(self.changeLanguage)
            self.updateLastimportedfiles()
            self.updateHistory()
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here
            pass


    def closePlugin(self):
        self.dlg.close()


    def showPrevisu(self, state):
        if state == Qt.Checked:
            self.dlg.setMaximumSize(900,622)
            self.dlg.resize(900,622)
        else:
            self.dlg.setMaximumSize(627,622)
            self.dlg.resize(627,622)


    def disableButtons(self):
        self.dlg.pushImportresource.setEnabled(False)
        self.dlg.pushExportAsNewresource.setEnabled(False)
        self.dlg.pushExportAsExistingresource.setEnabled(False)
        self.dlg.pushDeleteResource.setEnabled(False)
        self.dlg.pushDeletedataset.setEnabled(False)
        self.dlg.pushInfos.setEnabled(False)
        self.dlg.checkPrevisu.setEnabled(False)


    def enableButtons(self):
        self.dlg.pushImportresource.setEnabled(True)
        self.dlg.pushExportAsNewresource.setEnabled(True)
        self.dlg.pushExportAsExistingresource.setEnabled(True)
        self.dlg.pushDeleteResource.setEnabled(True)
        self.dlg.pushDeletedataset.setEnabled(True)
        self.dlg.pushInfos.setEnabled(True)
        self.dlg.checkPrevisu.setEnabled(True)


    def disableSearchButtons(self):
        self.dlg.ExecUrlApi.setEnabled(False)
        self.dlg.pushNewdataset.setEnabled(False)
        self.dlg.datasetId.setEnabled(False)
        self.dlg.pushChangedataset.setEnabled(False)
        self.dlg.exportLine.setEnabled(False)
        self.dlg.pushDisplayAllDatasets.setEnabled(False)
        self.dlg.pushDisplayAllDatasets2.setEnabled(False)


    def enableSearchButtons(self):
        self.dlg.ExecUrlApi.setEnabled(True)
        self.dlg.pushNewdataset.setEnabled(True)
        self.dlg.datasetId.setEnabled(True)
        self.dlg.pushChangedataset.setEnabled(True)
        self.dlg.exportLine.setEnabled(True)
        self.dlg.pushDisplayAllDatasets.setEnabled(True)
        self.dlg.pushDisplayAllDatasets2.setEnabled(True)


    def setupIcons(self):
        
        # Icon Paths
        arrow_bottom_icon_path = os.path.join(self.plugin_dir, 'img', 'arrow_bottom.png')
        arrow_double_icon_path = os.path.join(self.plugin_dir, 'img', 'arrow_double.png')
        arrow_top_icon_path = os.path.join(self.plugin_dir, 'img', 'arrow_top.png')
        csv_icon_path = os.path.join(self.plugin_dir, 'img', 'csv_icon.png')
        geojson_icon_path = os.path.join(self.plugin_dir, 'img', 'geojson_icon.png')
        json_icon_path = os.path.join(self.plugin_dir, 'img', 'json_icon.png')
        refresh_icon_path = os.path.join(self.plugin_dir, 'img', 'refresh_icon.png')
        search_icon_path = os.path.join(self.plugin_dir, 'img', 'search_icon.png')
        zip_icon_path = os.path.join(self.plugin_dir, 'img', 'zip_icon.png')
        add_icon_path = os.path.join(self.plugin_dir, 'img', 'add_icon.png')
        delete_icon_path = os.path.join(self.plugin_dir, 'img', 'delete_icon.png')
        update_icon_path = os.path.join(self.plugin_dir, 'img', 'update_icon.png')
        info_icon_path = os.path.join(self.plugin_dir, 'img', 'info_icon.png')
        d4c_icon_path = os.path.join(self.plugin_dir, 'img', 'd4c_icon.png')
        question_icon_path = os.path.join(self.plugin_dir, 'img', 'question_icon.png')
        france_icon_path = os.path.join(self.plugin_dir, 'img', 'france_icon.png')
        uk_icon_path = os.path.join(self.plugin_dir, 'img', 'uk_icon.png') 
        
        # Init Icons
        arrow_bottom = QIcon(arrow_bottom_icon_path)
        arrow_double = QIcon(arrow_double_icon_path)
        arrow_top = QIcon(arrow_top_icon_path)
        self.csv_icon = QIcon(csv_icon_path)
        self.geojson_icon = QIcon(geojson_icon_path)
        self.json_icon = QIcon(json_icon_path)
        refresh_icon = QIcon(refresh_icon_path)
        search_icon = QIcon(search_icon_path)
        self.zip_icon = QIcon(zip_icon_path)
        add_icon = QIcon(add_icon_path)
        delete_icon = QIcon(delete_icon_path)
        update_icon = QIcon(update_icon_path)
        info_icon = QIcon(info_icon_path)
        question_icon = QIcon(question_icon_path)
        france_icon = QIcon(france_icon_path)
        uk_icon = QIcon(uk_icon_path)


        # Set Icons
        self.dlg.pushWindowlogin.setIcon(arrow_double)
        self.dlg.ExecUrlApi.setIcon(search_icon)
        self.dlg.pushImportresource.setIcon(arrow_bottom)
        self.dlg.pushRefresh.setIcon(refresh_icon)
        self.dlg.pushExportAsNewresource.setIcon(arrow_top)
        self.dlg.pushExportAsExistingresource.setIcon(arrow_top)
        self.dlg.pushExportAsNewresource.setIcon(add_icon)
        self.dlg.pushExportAsExistingresource.setIcon(update_icon)
        self.dlg.pushDeleteResource.setIcon(delete_icon)
        self.dlg.pushNewdataset.setIcon(add_icon)
        self.dlg.pushDeletedataset.setIcon(delete_icon)
        self.dlg.pushInfos.setIcon(info_icon)
        self.dlg.label_13.setPixmap(QtGui.QPixmap(d4c_icon_path))
        self.dlg.pushChangedataset.setIcon(arrow_double)
        self.dlg.pushAbout.setIcon(info_icon)
        self.dlg.pushHelp.setIcon(question_icon)
        self.dlg.languageBox.addItem(france_icon, '')
        self.dlg.languageBox.addItem(uk_icon, '')

        # Set plugin version
        #self.dlg.label_pluginversion.setText('Version du plugin : v1.2')
        

    def resetVariablesForDataset(self):
        self.resourceDict = {}
        self.listExistingResourceById = {}
        self.selectedDataId = None
        self.selectedDataOrg = None
        self.selectedDataPrivate = None


    def read(self):
        with open(self.plugin_dir + '/help/source/_static/const/temp/k_e_y_p_w_d.txt', 'rb') as file:
            for line in file:
                self.key = line
            
        self.fernet = Fernet(self.key[2:-1])    
   

    def getD4Cdatasets(self):

        # Get the active tab 
        active_tab = self.dlg.tabWidget.currentIndex()



        if self.dlg.siteField.toPlainText() == '':
           if self.lang =='fr':
                self.show_error_message('URL Invalide !')
           else:
                self.show_error_message('Invalid URL !')
           return 
        else:
            url = self.dlg.siteField.toPlainText() + '/d4c/api/v1/dataset/find'
        
        #Reset variables
        self.dlg.resourcesList.clear()
        self.resetVariablesForDataset()
        if active_tab == 0:
            dataset_id = self.dlg.datasetId.text()
        else:
            dataset_id = self.dlg.exportLine.text()

        # Parameters of the request (data)
        data = {
            'dataset_id': dataset_id,
        }

        # headers of the request
        headers = {
        'Content-Type': 'application/x-www-form-urlencoded',  # Specify the data format (optional)
        }
        
        # Auth (if needed)
        auth = (self.usr, self.pwd)

        # POST request
        response = requests.post(url, data=data, headers=headers, auth=auth)

        if response.status_code == 200:
            dataset = response.json()
            if dataset['result'] == None:
                self.show_error_message('No dataset found')
            else:
                self.data_title = dataset['result']['title']
                data_name = dataset['result']['name']
                self.dlg.datasetId.setText(data_name)
                self.currentDataset_id = dataset['result']['id']
                self.data_author = dataset['result']['author']
                self.data_org = dataset['result']['organization']['title']
                self.data_license =dataset['result']['license_title']
                self.data_private = dataset['result']['private']
                self.selectedDataPrivate = dataset['result']['private']
                self.data_url =  dataset['result']['url']
                
                for resource in dataset['result']['resources']:
                    if resource['mimetype'] != "":
                        item = QtWidgets.QListWidgetItem(resource['name'])
                        self.dlg.resourcesList.setIconSize(QtCore.QSize(36, 36))
                        if resource['url'].endswith('.csv'):
                            item.setIcon(self.csv_icon)
                            self.dlg.resourcesList.addItem(item)
                        elif resource['url'].endswith('.geojson'):
                            item.setIcon(self.geojson_icon)
                            self.dlg.resourcesList.addItem(item)
                        elif resource['url'].endswith('.json'):
                            item.setIcon(self.json_icon)
                            self.dlg.resourcesList.addItem(item)
                        elif resource['url'].endswith('.zip'):
                            item.setIcon(self.zip_icon)
                            self.dlg.resourcesList.addItem(item)
                        else:
                            style = QApplication.style()
                            icon = style.standardIcon(QStyle.SP_TitleBarContextHelpButton)
                            item.setIcon(icon)
                            self.dlg.resourcesList.addItem(item)
                        
                        self.resourceDict[resource['name']] = resource['url']
                    self.listExistingResourceById[resource['name']] = resource['id']
                self.selectedDataId = dataset['result']['id']
                self.selectedDataOrg = dataset['result']['organization']['name']
                self.dlg.exportLine.setText(data_name)
                self.showExportableLayers()
                self.enableButtons()
                self.enableSearchButtons()
                self.saveSession()
                self.updateHistory()

        else:
            
            self.show_error_message('Error : ' + str(response.status_code))
        

    def openLoginsWindow(self):
        self.window = QtWidgets.QDialog()
        self.ui = Ui_LoginsWindow()
        self.ui.setupUi(self.window)
        #if not(self.isLoadedSite):
        self.ui.siteUrl.setText(self.sit)
        self.ui.user.setText(self.usr)
        self.ui.password.setText(self.pwd)
        
        # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')
            
        sites_file_path = os.path.join(os.path.expanduser("~") ,".d4cplugin", 'sites.json')

        self.ui.comboBox.clear()
        if os.path.exists(sites_file_path):
            with open(sites_file_path, 'r') as json_file:
                data = json.load(json_file)
                for sites in data['saved_sites']['sites']:
                    if sites['name'] == '':
                        self.ui.comboBox.addItem(sites['site_url'] + ' - ' + sites['username'])
                    else:
                        self.ui.comboBox.addItem(sites['name'])
        if self.ui.comboBox.count() == 0:
            self.ui.validLoadedSite.setEnabled(False)
        else:
            self.ui.validLoadedSite.setEnabled(True)
        self.ui.logins_window.loginsEntered.connect(self.getD4Clogins)
        self.window.exec_()
        self.updateHistory()
    

    def getD4Clogins(self, site_url, username, password, isLoadedSite):
        
        self.sit = site_url
        if self.sit.endswith('/') or self.sit.endswith(' '):
            self.sit = site_url[:-1]
        if self.sit.startswith(' '):
            self.sit = site_url[1:]
        self.sit=self.sit.lower()
        self.dlg.siteField.setPlainText(self.sit)
        
        self.usr = username
        if self.usr.endswith(' '):
            self.usr = username[:-1]
        if self.usr.startswith(' '):
            self.usr = username[1:]

        if password.startswith('b\''):
            pwd = self.fernet.decrypt(password[1:-1])
            pwd = pwd.decode('utf-8')
            self.pwd = pwd
        else:
            self.pwd = password
            if self.pwd.endswith(' '):
                self.pwd = self.pwd[:-1]
            if self.pwd.startswith(' '):
                self.pwd = self.pwd[1:]

        self.window.close()
        self.enableSearchButtons()
        if isLoadedSite:
            self.isLoadedSite = True
        else:
            self.isLoadedSite = False
            self.saveSites()
 

    def importResource(self):
        # Get the selected resource
        value = self.dlg.resourcesList.currentItem()

        if value:

            value = value.text()
            #Get the URL of the selected resource
            url = self.resourceDict[value]
            # Set up the destination folder
            if not os.path.exists(self.plugin_dir + '/resources/'):
                os.makedirs(self.plugin_dir + '/resources/')
            destination_folder = self.plugin_dir + '/resources/'
            
            # Set up the file name
            if url.endswith('.json') and not(value.endswith('.json')):
                file_name = value + '.json'
            elif url.endswith('.csv') and not(value.endswith('.csv')):
                file_name = value + '.csv'
            elif url.endswith('.geojson') and not(value.endswith('.geojson')):
                file_name = value + '.geojson'    
            else:
                file_name = value
            # Set up the destination path
            destination_path = os.path.join(destination_folder, file_name.replace('/', '_'))

            # Download the file
            try : 
                response = requests.get(url)

                if response.status_code == 200:
                    #write file content
                    with open(destination_path, 'wb') as f:
                        f.write(response.content)
                else:
                    self.show_error_message('Error downloading file : ' + str(response.status_code))

                #CSV import 
                if file_name.endswith('.csv'):

                    self.importCSV(destination_path, file_name)
                    
                #JSON import
                if file_name.endswith('.json'):
                    
                    self.importJSON(destination_path, file_name)
                            

                #GeoJSON import
                if file_name.endswith('.geojson'):
                    
                    self.importGEOJSON(destination_path, file_name)

                self.updateLastimportedfiles()

                
            except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

            except requests.exceptions.HTTPError as e:
                # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                self.show_error_message(f"HTTP error : {e.response.status_code}")

            except requests.exceptions.ConnectionError as e:
                # Gestion des erreurs de connexion
                self.show_error_message(f"Connection error : {e}")

            except requests.exceptions.Timeout as e:
                # Gestion des erreurs de délai d'attente
                self.show_error_message(f"Expired request : : {e}")

            except requests.exceptions.TooManyRedirects as e:
                # Gestion des erreurs de redirections excessives
                self.show_error_message(f"Too many redirects ! : : {e}")

            except requests.exceptions.RequestException as e:
                # Gestion générale des exceptions de requête
                self.show_error_message(f"Request error : {e}")

            except Exception as e:
                # Gestion d'autres exceptions non spécifiques
                self.show_error_message(f"Unhandled error occured: {e}")


        else: 
            if self.lang == 'fr':
                self.show_info_message('Veuillez sélectionner une ressource')
            else:
                self.show_info_message('Please select a resource')

    def importCSV(self, destination_path, file_name):
        layer_name = file_name
            
        csv_layer = QgsVectorLayer(destination_path, layer_name, "ogr")

        if not csv_layer.isValid():
            self.show_error_message("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(csv_layer)
            if self.lang == 'fr':
                self.show_success_message('Fichier importé avec succès')
            else:
                self.show_success_message('File imported successfully')

    def importJSON(self,destination_path,file_name):


        layer_name = file_name
            
        json_layer = QgsVectorLayer(destination_path, layer_name, "ogr")

        if not json_layer.isValid():
            self.show_error_message("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(json_layer)
            if self.lang == 'fr':
                self.show_success_message('Fichier importé avec succès')
            else:
                self.show_success_message('File imported successfully')


    def importGEOJSON(self,destination_path,file_name):
        layer_name = file_name

        v1 = QgsVectorLayer(
            f"{destination_path}", 
            layer_name,
            "ogr"
        ) 

        if not v1.isValid():
            self.show_error_message("Layer failed to load!")
        else:
            QgsProject.instance().addMapLayer(v1)
            if self.lang == 'fr':
                self.show_success_message('Fichier importé avec succès')
            else:
                self.show_success_message('File imported successfully')


    def emptyCache(self):
        directory_path = self.plugin_dir + '/resources/'
        openned_layers = QgsProject.instance().mapLayers().values()
        list_openned_layers = []
        for layer in openned_layers:
            projet = QgsProject.instance().mapLayersByName(layer.name())[0]
            url = projet.dataProvider().dataSourceUri()
            list_openned_layers.append(url)
        try:
            files = os.listdir(directory_path)
            for file in files:
                file_path = os.path.join(directory_path, file)
                if file_path not in list_openned_layers:
                    if os.path.isfile(file_path):
                        os.remove(file_path)       

            if self.lang == 'fr':
                self.show_success_message('Cache vidé avec succès')
            else:
                self.show_success_message('Cache emptied successfully')
        except OSError:
            self.show_error_message("Error occurred while deleting files. (Files may be openned in QGIS)")

        self.updateLastimportedfiles()


    def showExportableLayers(self):
        

        exportable_layers = QgsProject.instance().mapLayers().values()
        self.dlg.layersList.clear()
        for layer in exportable_layers:
            item_name = layer.name()

            if item_name != 'OpenStreetMap':
                item = QtWidgets.QListWidgetItem(item_name)
                self.dlg.layersList.setIconSize(QtCore.QSize(36, 36))
                if item_name.endswith('.csv'):
                    item.setIcon(self.csv_icon)
                    self.dlg.layersList.addItem(item)
                elif item_name.endswith('.geojson'):
                    item.setIcon(self.geojson_icon)
                    self.dlg.layersList.addItem(item)
                elif item_name.endswith('.json'):
                    item.setIcon(self.json_icon)
                    self.dlg.layersList.addItem(item)
                elif not(item_name.endswith('.csv')) and QgsProject.instance().mapLayersByName(item_name)[0].dataProvider().dataSourceUri().endswith('.csv'):
                    item.setIcon(self.csv_icon)
                    self.dlg.layersList.addItem(item)
                elif not(item_name.endswith('.geojson')) and QgsProject.instance().mapLayersByName(item_name)[0].dataProvider().dataSourceUri().endswith('.geojson'):
                    item.setIcon(self.geojson_icon)
                    self.dlg.layersList.addItem(item)
                elif not(item_name.endswith('.json')) and QgsProject.instance().mapLayersByName(item_name)[0].dataProvider().dataSourceUri().endswith('.json'):
                    item.setIcon(self.json_icon)
                    self.dlg.layersList.addItem(item)
                else:
                    self.dlg.layersList.addItem(item)


    def exportAsNewResource(self):
        # Créez une boîte de dialogue de confirmation
        confirmation = QMessageBox()
        confirmation.setIcon(QMessageBox.Question)
        confirmation.setWindowTitle("Confirmation")
        confirmation.setText(f"Ajouter la ressource au jeu de donnée {self.dlg.exportLine.text()} ?")

        # Ajoutez les boutons "Continuer" et "Annuler"
        confirmation.addButton(QMessageBox.Ok)
        confirmation.addButton(QMessageBox.Cancel)

        # Affichez la boîte de dialogue et attendez la réponse de l'utilisateur
        response = confirmation.exec_()

        # Vérifiez la réponse de l'utilisateur
        if response != QMessageBox.Ok:
            return
        item = self.dlg.layersList.currentItem()
        projet = QgsProject.instance()
        exportFormat = None
        if item:
            nom_couche = item.text()
            couche = projet.mapLayersByName(nom_couche)[0]

            if nom_couche.endswith('.geojson'):
                exportFormat = 'GeoJSON'
            
            # API URL
            url = self.dlg.siteField.toPlainText()+ '/d4c/api/v1/dataset/resource_add'

            # file to upload
            fichier = couche.dataProvider().dataSourceUri() 

            # request parameters
            if exportFormat == 'GeoJSON':
                data = {
                    'selected_data_id': self.selectedDataId,
                    'format': exportFormat,
                    'selected_private': self.selectedDataPrivate,  
                    'unzip_zip': 'true',  # always true by default
                    'selected_org': self.selectedDataOrg
                }
            else:
                data = {
                    'selected_data_id': self.selectedDataId,
                    'selected_private': self.selectedDataPrivate,  
                    'unzip_zip': 'true',  # always true by default
                    'selected_org': self.selectedDataOrg
                }
           
            #headers
            headers = {
                'Accept-Encoding': "gzip, deflate, br",
                'Connection': "keep-alive"
            }

            #Authentification
            auth = (self.usr, self.pwd)
           
            with open(fichier, 'rb') as file:

                file_size = os.path.getsize(fichier)
                # POST request

                try: 
                    
                    fichiers = {'upload_file': (fichier, file)}
                    response = requests.post(url, data=data, files=fichiers, headers=headers, auth=auth)

                    if response.status_code == 200:
                        response = response.json()
                        if response['status'] == "error":
                            self.show_error_message(response['result']['message'])
                        else:
                            if self.lang == 'fr':
                                self.show_success_message('Fichier exporté avec succès')
                            else:
                                self.show_success_message('File exported successfully')
                            
                    else:
                        self.show_error_message('Error : ' + str(response.status_code))
                
                except ConnectionAbortedError as e:
                    self.show_error_message(f"Server connection interrupt : {e}")
                    
                except requests.exceptions.ConnectionError as e:
                    # Gestion des erreurs de connexion
                    self.show_error_message(f"Connection error : {e}")
                
                except requests.exceptions.RequestException as e:
                    # Gestion des erreurs de requête
                    self.show_error_message(f"Request error : {e}")

                except requests.exceptions.HTTPError as e:
                    # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                    self.show_error_message(f"HTTP error : {e.response.status_code}")
                    
                except requests.exceptions.Timeout as e:
                    # Gestion des erreurs de délai d'attente
                    self.show_error_message(f"Expired request : : {e}")

                except requests.exceptions.TooManyRedirects as e:
                    # Gestion des erreurs de redirections excessives
                    self.show_error_message(f"Too many redirects ! : : {e}")

                except requests.exceptions.RequestException as e:
                    # Gestion générale des exceptions de requête
                    self.show_error_message(f"Request error : {e}")

                except Exception as e:
                    # Gestion d'autres exceptions non spécifiques
                    self.show_error_message(f"Unhandled error occured: {e}")


        else: 
            #display error message
            if self.lang == 'fr':
                self.show_info_message('Veuillez sélectionner une couche à exporter')
            else:
                self.show_info_message('Please select a layer to export')
        self.getD4Cdatasets()


    def showExistingResources(self):
        
        test = self.dlg.layersList.currentItem()
        if test or self.isDelete:
            self.window2 = QtWidgets.QDialog()
            self.ui2 = Ui_d4cAPIDialogExport()
            self.ui2.setupUi(self.window2)
            self.ui2.listResourceChoice.clear()
            resourceList = list(self.listExistingResourceById.keys())
            for resource in resourceList:
                
                item = QtWidgets.QListWidgetItem(resource)
                self.ui2.listResourceChoice.setIconSize(QtCore.QSize(36, 36))
                if resource.endswith('.csv'):
                    item.setIcon(self.csv_icon)
                    self.ui2.listResourceChoice.addItem(item)
                elif resource.endswith('.geojson'):
                    item.setIcon(self.geojson_icon)
                    self.ui2.listResourceChoice.addItem(item)
                elif resource.endswith('.json'):
                    item.setIcon(self.json_icon)
                    self.ui2.listResourceChoice.addItem(item)
                else:
                    self.ui2.listResourceChoice.addItem(item)
                
            if self.isDelete:
                self.ui2.export_window.exportEntered.connect(self.deleteResource_selected)
            else:
                self.ui2.export_window.exportEntered.connect(self.exportAsExistingResource)
            self.window2.exec_()
        else:
            if self.lang == 'fr':
                self.show_info_message('Veuillez sélectionner une couche à exporter')
            else:
                self.show_info_message('Please select a layer to export')


    def exportAsExistingResource(self, resource_name):
        
        if resource_name != '':
            resourceID = self.listExistingResourceById[resource_name]
            exportFormat = None
            item = self.dlg.layersList.currentItem()
            projet = QgsProject.instance()
            if item:
                nom_couche = item.text()
                couche = projet.mapLayersByName(nom_couche)[0]

                if nom_couche.endswith('.geojson'):
                    exportFormat = 'GeoJSON'
                # API URL
                url = self.dlg.siteField.toPlainText()+ '/d4c/api/v1/dataset/resource_add'

                # file to upload
                fichier = couche.dataProvider().dataSourceUri() 
                # request parameters
                if exportFormat == 'GeoJSON':
                    data = {
                        'selected_data_id': self.selectedDataId,
                        'selected_private': self.selectedDataPrivate,  
                        'unzip_zip': 'true',  # always true by default
                        'selected_org': self.selectedDataOrg,
                        'selected_resource_id': resourceID,
                    }
                else:
                    data = {
                        'selected_data_id': self.selectedDataId,
                        'selected_private': self.selectedDataPrivate,  
                        'unzip_zip': 'true',  # always true by default
                        'selected_org': self.selectedDataOrg,
                        'selected_resource_id': resourceID,
                        
                        
                    }
                #headers
                headers = {
                    'Accept-Encoding': "gzip, deflate, br",
                    'Connection': "keep-alive"
                }

                #Authentification
                auth = (self.usr, self.pwd)

                with open(fichier, 'rb') as file:

                    file_size = os.path.getsize(fichier)
                    # POST request
                    try:
                    
                        fichiers = {'upload_file': (fichier, file)}
                        response = requests.post(url, data=data, files=fichiers, headers=headers, auth=auth)

                        response.raise_for_status()

                        if self.lang == 'fr':
                            self.show_success_message('Fichier exporté avec succès')
                        else:
                            self.show_success_message('File exported successfully')
                        self.window2.close()
                        
                    except requests.exceptions.RequestException as e:
                        # Gestion des erreurs de requête
                        self.show_error_message(f"Request error : {e}")

                    except requests.exceptions.HTTPError as e:
                        # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                        self.show_error_message(f"HTTP error : {e.response.status_code}")

                    except requests.exceptions.ConnectionError as e:
                        # Gestion des erreurs de connexion
                        self.show_error_message(f"Connection error : {e}")

                    except requests.exceptions.Timeout as e:
                        # Gestion des erreurs de délai d'attente
                        self.show_error_message(f"Expired request : : {e}")

                    except requests.exceptions.TooManyRedirects as e:
                        # Gestion des erreurs de redirections excessives
                        self.show_error_message(f"Too many redirects ! : : {e}")

                    except requests.exceptions.RequestException as e:
                        # Gestion générale des exceptions de requête
                        self.show_error_message(f"Request error : {e}")

                    except Exception as e:
                        # Gestion d'autres exceptions non spécifiques
                        self.show_error_message(f"Unhandled error occured: {e}")

                    except ConnectionAbortedError as e:
                        self.show_error_message(f"Server connection interrupt : {e}")


            else: 
                #display error message
                if self.lang == 'fr':
                    self.show_info_message('Veuillez sélectionner une couche à exporter')
                else: 
                    self.show_info_message('Please select a layer to export')
            self.getD4Cdatasets()
        else:
            if self.lang == 'fr':
                self.show_info_message('Veuillez sélectionner une ressource à remplacer')
            else:
                self.show_info_message('Please select a resource to replace')


    def show_error_message(self, message):
        error_box = QMessageBox()
        error_box.setIcon(QMessageBox.Critical)
        error_box.setWindowTitle('Erreur')
        error_box.setText(message)
        error_box.exec_()


    def show_success_message(self, message):
        success_box = QMessageBox()
        success_box.setIcon(QMessageBox.Information)
        success_box.setWindowTitle('Succès')
        success_box.setText(message)
        success_box.exec_()
    

    def show_info_message(self, message):
        info_box = QMessageBox()
        info_box.setIcon(QMessageBox.Information)
        info_box.setWindowTitle('Information')
        info_box.setText(message)
        info_box.exec_()


    def saveSession(self):
        site_url = self.sit
        username = self.usr
        password = self.pwd

        encrypted_password = self.fernet.encrypt(password.encode())
        
        datasets = self.dlg.datasetId.text()

        # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')
            
        # Chargez les sessions existantes depuis le fichier JSON
        destination_folder = os.path.expanduser('~/.d4cplugin')  # Modifier le chemin selon vos besoins
        json_file_path = os.path.join(destination_folder, 'logs.json')
        
        if os.path.exists(json_file_path):
            with open(json_file_path, 'r') as json_file:
                data = json.load(json_file)
        else:
            data = {
                "last_session": {
                    "sessions": []
                },
                "lang": ""
            }
        
        # Ajoutez la nouvelle session aux données
        new_session = {
            "site_url": site_url,
            "username": username,
            "datasets": datasets,
            "password": str(encrypted_password),
        }
        data["last_session"]["sessions"].insert(0, new_session)  # Insérer la nouvelle session au début

        # Limitez le nombre de sessions à 3
        if len(data["last_session"]["sessions"]) > 10:
            data["last_session"]["sessions"].pop()  # Supprime la session la plus ancienne

        # Enregistrez les données mises à jour dans le fichier JSON
        with open(json_file_path, 'w') as json_file:
            json.dump(data, json_file, indent=4)


    def saveSites(self):
        site_url = self.sit
        username = self.usr
        password = self.pwd

        encrypted_password = self.fernet.encrypt(password.encode())
         # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')

        sites_file_path = os.path.join(os.path.expanduser("~"), '.d4cplugin', 'sites.json')

        if os.path.exists(sites_file_path):
            # Charger les données JSON existantes
            with open(sites_file_path, 'r') as json_file:
                site_data = json.load(json_file)
        else:
            site_data = {
                "saved_sites": {
                    "sites": []
                }
            }

        # Vérifier si la nouvelle entrée est identique à une entrée existante
        for site_info in site_data["saved_sites"]["sites"]:
            if site_info.get("site_url") == site_url and site_info.get("username") == username:
                # Si l'entrée est identique, ne la sauvegarde pas à nouveau
                return

        # Ajouter la nouvelle entrée aux données
        new_site_info = {
            "site_url": site_url,
            "name" : "",
            "username": username,
            "password": str(encrypted_password),  # N'oubliez pas de chiffrer le mot de passe
        }
        site_data["saved_sites"]["sites"].append(new_site_info)

        # Enregistrer les données mises à jour dans le fichier sites.json
        with open(sites_file_path, 'w') as json_file:
            json.dump(site_data, json_file, indent=4)

    
    def updateHistory(self):
        
        self.dlg.historyList.clear()
        # Définir le chemin du fichier JSON
                # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')
            
        destination_folder = os.path.join(os.path.expanduser("~"), '.d4cplugin')
        json_file_path = os.path.join(destination_folder, 'logs.json')
        json_sites_file_path = os.path.join(destination_folder, 'sites.json')

        if os.path.exists(json_file_path) and os.path.exists(json_sites_file_path):
            with open(json_file_path, 'r') as json_file:
                data = json.load(json_file)
                
        
            with open(json_sites_file_path, 'r') as json_sites_file:
                data_sites = json.load(json_sites_file)
    

            sessions = data["last_session"]["sessions"]
            sites = data_sites["saved_sites"]["sites"]
            for session in sessions:
                if session["site_url"] != None:
                    for site in sites:
                        if site["site_url"] == session["site_url"] and site["username"] == session["username"] and site["name"] != "":
                            item = QtWidgets.QListWidgetItem(site["name"] + ' => ' + session["datasets"])
                            
                            break
                    
                        item = QtWidgets.QListWidgetItem(session["site_url"] + ' - ' + session["username"] + ' => ' + session["datasets"])
                    self.dlg.historyList.addItem(item)    


    def loadPreviousSession(self):
        session = self.dlg.historyList.currentItem()
        sessionNb = self.dlg.historyList.currentRow()
        # Set up the destination folder
        if not os.path.exists(os.path.expanduser("~") + '/.d4cplugin/'):
            os.makedirs(os.path.expanduser("~") + '/.d4cplugin/')
            
        destination_folder = os.path.join(os.path.expanduser("~"), '.d4cplugin')
        json_file_path = os.path.join(destination_folder, 'logs.json')


        if not(session):
            return
           

        with open(json_file_path, 'r') as json_file:
            data = json.load(json_file)
            previousSit = data["last_session"]["sessions"][sessionNb]["site_url"]
            previousUsr = data["last_session"]["sessions"][sessionNb]["username"]
            previousDataset = data["last_session"]["sessions"][sessionNb]["datasets"]
            mdp = data["last_session"]["sessions"][sessionNb]["password"]
        
        mdp = self.fernet.decrypt(mdp[1:-1])
        mdp = mdp.decode('utf-8')
        self.pwd = mdp
        self.sit = previousSit
        self.usr = previousUsr
        self.dlg.datasetId.setText(previousDataset)
        self.dlg.siteField.setPlainText(previousSit) 

        self.getD4Cdatasets()


    def openAddDatasetWindow(self):
        self.window3 = QtWidgets.QDialog()
        self.ui3 = Ui_Dialog()
        self.ui3.setupUi(self.window3)
        site = self.sit + "/d4c/api/datasets/2.0/search/facet.field=%5B%22organization%22%5D"
        
        try: 
            org_list = requests.get(site)


            if org_list.status_code == 200:
                org_list = org_list.json()
                for org in org_list['result']['facets']['organization']:
                    self.ui3.orgCombobox.addItem(org)
                
                sites_file_path = os.path.join(os.path.expanduser("~"), '.d4cplugin', 'sites.json')
                with open(sites_file_path, 'r') as json_file:
                    site_data = json.load(json_file)
                sites = site_data["saved_sites"]["sites"]
                for site in sites:
                    self.ui3.comboBox.addItem(site["name"])
                self.ui3.comboBox.setCurrentIndex(self.currentSiteIndex())
        
                self.ui3.comboBox.currentIndexChanged.connect(self.changeSite)

                self.ui3.dataset_entered.datasetEntered.connect(self.addDataset)
                self.window3.exec_()
            else:
                if self.lang == 'fr':
                    self.show_error_message('Erreur lors de la récupération des organisations')
                else:
                    self.show_error_message('Error while getting organizations')
                return
        except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

        except requests.exceptions.HTTPError as e:
            # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
            self.show_error_message(f"HTTP error : {e.response.status_code}")

        except requests.exceptions.ConnectionError as e:
            # Gestion des erreurs de connexion
            self.show_error_message(f"Connection error : {e}")

        except requests.exceptions.Timeout as e:
            # Gestion des erreurs de délai d'attente
            self.show_error_message(f"Expired request : : {e}")

        except requests.exceptions.TooManyRedirects as e:
            # Gestion des erreurs de redirections excessives
            self.show_error_message(f"Too many redirects ! : : {e}")

        except requests.exceptions.RequestException as e:
            # Gestion générale des exceptions de requête
            self.show_error_message(f"Request error : {e}")

        except Exception as e:
            # Gestion d'autres exceptions non spécifiques
            self.show_error_message(f"Unhandled error occured: {e}")

        
    def changeSite(self):
        itemNb = self.ui3.comboBox.currentIndex()

        if itemNb != -1:
            sites_file_path = os.path.join(os.path.expanduser("~"), '.d4cplugin', 'sites.json')
            with open(sites_file_path, 'r') as json_file:
                site_data = json.load(json_file)
                sites = site_data["saved_sites"]["sites"]
                self.sit = sites[itemNb]["site_url"]
                self.usr = sites[itemNb]["username"]
                self.pwd = self.fernet.decrypt(sites[itemNb]["password"][1:-1])
                self.pwd = self.pwd.decode('utf-8')
                self.dlg.siteField.setPlainText(self.sit)
            site = self.sit + "/d4c/api/datasets/2.0/search/facet.field=%5B%22organization%22%5D"
        
            try: 
                org_list = requests.get(site)


                if org_list.status_code == 200:
                    org_list = org_list.json()
                    self.ui3.orgCombobox.clear()
                    for org in org_list['result']['facets']['organization']:
                        self.ui3.orgCombobox.addItem(org)
            except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

            except requests.exceptions.HTTPError as e:
                # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                self.show_error_message(f"HTTP error : {e.response.status_code}")

            except requests.exceptions.ConnectionError as e:
                # Gestion des erreurs de connexion
                self.show_error_message(f"Connection error : {e}")

            except requests.exceptions.Timeout as e:
                # Gestion des erreurs de délai d'attente
                self.show_error_message(f"Expired request : : {e}")

            except requests.exceptions.TooManyRedirects as e:
                # Gestion des erreurs de redirections excessives
                self.show_error_message(f"Too many redirects ! : : {e}")

            except requests.exceptions.RequestException as e:
                # Gestion générale des exceptions de requête
                self.show_error_message(f"Request error : {e}")

            except Exception as e:
                # Gestion d'autres exceptions non spécifiques
                self.show_error_message(f"Unhandled error occured: {e}")


    def addDataset(self, name, org, private):

        data = {
            'name': name,
            'title': name,
            'selected_private': private,
            'selected_org': org            
        }

        url = self.sit + '/d4c/api/v1/dataset/manage'

        auth = (self.usr, self.pwd)

        try: 
            response = requests.post(url, data=data, auth=auth)

            if response.status_code == 200:
                response = response.json()
                if response['status'] == "error":
                    if self.lang == 'fr':
                        self.show_error_message('Erreur lors de la création du dataset')
                    else:
                        self.show_error_message('Error while creating dataset')
                else:
                    if self.lang == 'fr':
                        self.show_success_message('Dataset ajouté avec succès')
                    else:
                        self.show_success_message('Dataset added successfully')
                    self.dlg.datasetId.setText(response['result'])
                    self.getD4Cdatasets()
                    self.window3.close()
        except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

        except requests.exceptions.HTTPError as e:
            # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
            self.show_error_message(f"HTTP error : {e.response.status_code}")

        except requests.exceptions.ConnectionError as e:
            # Gestion des erreurs de connexion
            self.show_error_message(f"Connection error : {e}")

        except requests.exceptions.Timeout as e:
            # Gestion des erreurs de délai d'attente
            self.show_error_message(f"Expired request : : {e}")

        except requests.exceptions.TooManyRedirects as e:
            # Gestion des erreurs de redirections excessives
            self.show_error_message(f"Too many redirects ! : : {e}")

        except requests.exceptions.RequestException as e:
            # Gestion générale des exceptions de requête
            self.show_error_message(f"Request error : {e}")

        except Exception as e:
            # Gestion d'autres exceptions non spécifiques
            self.show_error_message(f"Unhandled error occured: {e}")
    

    def deleteResource(self):
        
        self.isDelete = True
        self.showExistingResources()
        

    def deleteResource_selected(self, resource_name):
        # Créez une boîte de dialogue de confirmation
        confirmation = QMessageBox()
        confirmation.setIcon(QMessageBox.Question)
        confirmation.setWindowTitle("Confirmation")
        confirmation.setText("Êtes-vous sûr de vouloir supprimer la ressource ? Cette action est irréversible.")

        # Ajoutez les boutons "Continuer" et "Annuler"
        confirmation.addButton(QMessageBox.Ok)
        confirmation.addButton(QMessageBox.Cancel)

        # Affichez la boîte de dialogue et attendez la réponse de l'utilisateur
        response = confirmation.exec_()

        # Vérifiez la réponse de l'utilisateur
        if response == QMessageBox.Ok:
            # L'utilisateur a choisi de continuer, vous pouvez appeler la fonction de suppression ici
            if resource_name != '':
                resourceID = self.listExistingResourceById[resource_name]

                url = self.dlg.siteField.toPlainText()+ '/d4c/api/v1/dataset/resource_remove'

                data = {
                    'resource_id': resourceID,
                }

                try: 

                    response = requests.post(url, data=data, auth=(self.usr, self.pwd))

                    if response.status_code == 200:
                        response = response.json()
                        if response['status'] == "error":
                            if self.lang == 'fr':
                                self.show_error_message('Erreur lors de la suppression de la ressource')
                            else:
                                self.show_error_message('Error while deleting resource')
                        else:
                            if self.lang == 'fr':
                                self.show_success_message('Ressource supprimée avec succès')
                            else:
                                self.show_success_message('Resource deleted successfully')
                            self.getD4Cdatasets()
                            self.window2.close()

                except requests.exceptions.RequestException as e:
                    # Gestion des erreurs de requête
                    self.show_error_message(f"Request error : {e}")

                except requests.exceptions.HTTPError as e:
                    # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                    self.show_error_message(f"HTTP error : {e.response.status_code}")

                except requests.exceptions.ConnectionError as e:
                    # Gestion des erreurs de connexion
                    self.show_error_message(f"Connection error : {e}")

                except requests.exceptions.Timeout as e:
                    # Gestion des erreurs de délai d'attente
                    self.show_error_message(f"Expired request : : {e}")

                except requests.exceptions.TooManyRedirects as e:
                    # Gestion des erreurs de redirections excessives
                    self.show_error_message(f"Too many redirects ! : : {e}")

                except requests.exceptions.RequestException as e:
                    # Gestion générale des exceptions de requête
                    self.show_error_message(f"Request error : {e}")

                except Exception as e:
                    # Gestion d'autres exceptions non spécifiques
                    self.show_error_message(f"Unhandled error occured: {e}")

                except ConnectionAbortedError as e:
                    self.show_error_message(f"Server connection interrupt : {e}")
        else:
            # L'utilisateur a choisi d'annuler, ne faites rien ou effectuez une action d'annulation si nécessaire
            pass
           
    
    def deleteDataset(self):
    
        # Créez une boîte de dialogue de confirmation
        confirmation = QMessageBox()
        confirmation.setIcon(QMessageBox.Question)
        confirmation.setWindowTitle("Confirmation")
        confirmation.setText("Êtes-vous sûr de vouloir supprimer le Jeu de Donnée ? Cette action est irréversible.")

        # Ajoutez les boutons "Continuer" et "Annuler"
        confirmation.addButton(QMessageBox.Ok)
        confirmation.addButton(QMessageBox.Cancel)

        # Affichez la boîte de dialogue et attendez la réponse de l'utilisateur
        response = confirmation.exec_()

        # Vérifiez la réponse de l'utilisateur
        if response == QMessageBox.Ok:
            url = self.dlg.siteField.toPlainText()+ '/d4c/api/v1/dataset/remove'

            data = {
                'dataset_id' : self.currentDataset_id
            }

            auth = (self.usr, self.pwd)

            try:

                response = requests.post(url, data=data, auth=auth)

                if response.status_code == 200:
                    response = response.json()
                    if response['status'] == "error":
                        if self.lang == 'fr':
                            self.show_error_message('Erreur lors de la suppression du dataset')
                        else:
                            self.show_error_message('Error while deleting dataset')
                    else:
                        if self.lang == 'fr':
                            self.show_success_message('Dataset supprimé avec succès')
                        else:
                            self.show_success_message('Dataset deleted successfully')
                        self.dlg.datasetId.setText('')
                        self.dlg.exportLine.setText('')
                        self.dlg.resourcesList.clear()
                        self.resetVariablesForDataset()
                else:
                    self.show_error_message('Error : ' + str(response.status_code))
            
            except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

            except requests.exceptions.HTTPError as e:
                # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                self.show_error_message(f"HTTP error : {e.response.status_code}")

            except requests.exceptions.ConnectionError as e:
                # Gestion des erreurs de connexion
                self.show_error_message(f"Connection error : {e}")

            except requests.exceptions.Timeout as e:
                # Gestion des erreurs de délai d'attente
                self.show_error_message(f"Expired request : : {e}")

            except requests.exceptions.TooManyRedirects as e:
                # Gestion des erreurs de redirections excessives
                self.show_error_message(f"Too many redirects ! : : {e}")

            except requests.exceptions.RequestException as e:
                # Gestion générale des exceptions de requête
                self.show_error_message(f"Request error : {e}")

            except Exception as e:
                # Gestion d'autres exceptions non spécifiques
                self.show_error_message(f"Unhandled error occured: {e}")

            except ConnectionAbortedError as e:
                self.show_error_message(f"Server connection interrupt : {e}")
        
        else:
            # L'utilisateur a choisi d'annuler, ne faites rien ou effectuez une action d'annulation si nécessaire
            pass


    def showInfoWindow(self):
        self.windowInfo = QtWidgets.QDialog()
        self.uiInfo = Ui_showInfos()
        self.uiInfo.setupUi(self.windowInfo)
        self.uiInfo.datasetTitlefield.setPlainText(self.data_title)
        self.uiInfo.datasetAuthorfield.setPlainText(self.data_author)
        self.uiInfo.datasetOrgfield.setPlainText(self.data_org)
        self.uiInfo.datasetLicensefield.setPlainText(self.data_license)
        self.uiInfo.datasetPrivatefield.setPlainText(str(self.data_private))
        self.uiInfo.datasetUrlfield.setPlainText(self.data_url)
        self.uiInfo.closeInfos.clicked.connect(self.windowInfo.close)
        self.windowInfo.exec_()


    def updateLastimportedfiles(self):

        # Set up the destination folder
        if not os.path.exists(self.plugin_dir + '/resources/'):
            os.makedirs(self.plugin_dir + '/resources/')

        files_path = os.path.join(self.plugin_dir, 'resources')
        files = os.listdir(files_path)

        self.dlg.filesList.clear()
        for file in files:
            if file.endswith('.csv') or file.endswith('.geojson') or file.endswith('.json'):
                self.dlg.filesList.addItem(file)
        

    def openResourceFile(self):

        directory_path = os.path.join(self.plugin_dir, 'resources')
        subprocess.run(f'cd /d "{directory_path}" && start .', shell=True)


    def openResourcefromFile(self):
        
        item = self.dlg.filesList.currentItem()
        if item:
            file_name = item.text()
            destination_path = os.path.join(self.plugin_dir,'resources', file_name)
            if file_name.endswith('.csv'):
                self.importCSV(destination_path, file_name)
            elif file_name.endswith('.geojson'):
                self.importGEOJSON(destination_path, file_name)
            elif file_name.endswith('.json'):
                self.importJSON(destination_path, file_name)
            else:
                return

                
    def openAllDatasets(self):
        self.dlg.setEnabled(False)
        self.windowAllDatasets = QtWidgets.QDialog()
        self.uiAllDatasets = Ui_searchDataset()
        self.uiAllDatasets.setupUi(self.windowAllDatasets)
        self.uiAllDatasets.checkDisplayGeo.setChecked(True)
        
        


        url = self.dlg.siteField.toPlainText()+ '/d4c/api/datasets/2.0/search?start=0&rows=1000'
        if not(self.isAlldatasetsLoaded):
            self.Alldatasetlist = []
            try:
                
                self.show_info_message(self.tr(u'Veuillez patienter pendant le chargement des données'))
                
                response = requests.get(url)

            # [nom][format][tags][themes][organisation]
                if response.status_code == 200:
                    data = response.json()
                    data_fill = []
                    format_fill = []
                    tags_fill = []
                    for dataset in data['result']['results']:
                        data_fill.append(dataset['title'])
                        for resource in dataset['resources']:
                            format_fill.append(resource['format'])
                        data_fill.append(format_fill)
                        for tag in dataset['tags']:
                            tags_fill.append(tag['name'])
                        data_fill.append(tags_fill)
                        for extra in dataset['extras']:
                            if extra['key'] == 'themes':
                                themefound = True
                                themes = json.loads(extra['value'])
                                if isinstance(themes, list):
                                    data_fill.append(themes)
                                else:
                                    data_fill.append(extra['value'])
                        if not(themefound):
                            data_fill.append([])
                        data_fill.append(dataset['organization']['title'])
                        data_fill.append(dataset['name'])
                        self.Alldatasetlist.append(data_fill)
                        data_fill = []
                        format_fill = []
                        tags_fill = []
                        themefound = False
                    self.isAlldatasetsLoaded = True

            except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

            except requests.exceptions.HTTPError as e:
                # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                self.show_error_message(f"HTTP error : {e.response.status_code}")

            except requests.exceptions.ConnectionError as e:
                # Gestion des erreurs de connexion
                self.show_error_message(f"Connection error : {e}")

            except requests.exceptions.Timeout as e:
                # Gestion des erreurs de délai d'attente
                self.show_error_message(f"Expired request : : {e}")

            except requests.exceptions.TooManyRedirects as e:
                # Gestion des erreurs de redirections excessives
                self.show_error_message(f"Too many redirects ! : : {e}")

            except requests.exceptions.RequestException as e:
                # Gestion générale des exceptions de requête
                self.show_error_message(f"Request error : {e}")

            except Exception as e:
                # Gestion d'autres exceptions non spécifiques
                self.show_error_message(f"Unhandled error occured: {e}") 
      
        self.uiAllDatasets.datasetAllList.setIconSize(QtCore.QSize(24, 24))
        for i in range(len(self.Alldatasetlist)):
            if "GeoJSON" in self.Alldatasetlist[i][1]:
                item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
                item.setIcon(self.geojson_icon)
                item.setToolTip(self.Alldatasetlist[i][0])
                self.uiAllDatasets.datasetAllList.addItem(item)
            # elif "CSV" in self.Alldatasetlist[i][1]:
            #     item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
            #     item.setForeground(Qt.green)
            #     self.uiAllDatasets.datasetAllList.addItem(item)
            # elif "JSON" in self.Alldatasetlist[i][1]:
            #     item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
            #     item.setForeground(Qt.yellow)
            #     self.uiAllDatasets.datasetAllList.addItem(item)
            else:
                item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
                item.setToolTip(self.Alldatasetlist[i][0])
                self.uiAllDatasets.datasetAllList.addItem(item)

        themes_set = set(theme for dataset in self.Alldatasetlist for theme in dataset[3])

        organizations_set = set(dataset[4] for dataset in self.Alldatasetlist)

        tags_set = set(tag for dataset in self.Alldatasetlist for tag in dataset[2])

        self.uiAllDatasets.dynamic_taglist = []

        self.uiAllDatasets.alldatasets = self.Alldatasetlist

        self.uiAllDatasets.scrollAreaWidgetContents_3.setLayout(self.uiAllDatasets.scrollLayout2)
        self.uiAllDatasets.scrollAreaWidgetContents_4.setLayout(self.uiAllDatasets.scrollLayout3)

        if self.dlg.languageBox.currentIndex() == 0:
            self.uiAllDatasets.comboBox.addItem("Choisir une organisation")
        else:
            self.uiAllDatasets.comboBox.addItem("Choose an organization")

        for organization in organizations_set:
            self.uiAllDatasets.comboBox.addItem(organization)
        self.uiAllDatasets.comboBox.setCurrentIndex(0)
        
        self.uiAllDatasets.themes_checkboxes = []
        for theme in themes_set:
            checkbox = QtWidgets.QCheckBox(theme)
            checkbox.setObjectName(theme)
            self.uiAllDatasets.themes_checkboxes.append(checkbox)
            self.uiAllDatasets.scrollLayout2.addWidget(checkbox)
        
        self.uiAllDatasets.tags_checkboxes = []
        for tag in tags_set:
            checkbox = QtWidgets.QCheckBox(tag)
            checkbox.setObjectName(tag)
            self.uiAllDatasets.tags_checkboxes.append(checkbox)
            self.uiAllDatasets.scrollLayout3.addWidget(checkbox)
        




            
        self.dlg.setEnabled(True) 
        
        self.uiAllDatasets.checkDisplayGeo.setChecked(True)
        self.filterNonGeo(Qt.Checked)
        self.uiAllDatasets.checkDisplayGeo.stateChanged.connect(self.filterNonGeo)
        self.uiAllDatasets.pushFilter.clicked.connect(self.resetFilters)
        
        for checkbox in self.uiAllDatasets.themes_checkboxes + self.uiAllDatasets.tags_checkboxes:
            checkbox.stateChanged.connect(self.filterDatasetviaCheckbox)
        self.uiAllDatasets.comboBox.currentTextChanged.connect(self.filterDatasetviaCheckbox)
        self.uiAllDatasets.pushClose.clicked.connect(self.windowAllDatasets.close)
        self.uiAllDatasets.searchBarFilter.textChanged.connect(self.filterAllDatasets)
        self.uiAllDatasets.search_dataset.datasetEntered.connect(self.getD4CdatasetsfromAll)
        self.uiAllDatasets.checkAz.stateChanged.connect(self.sortDatasetAz)
        self.uiAllDatasets.checkZa.stateChanged.connect(self.sortDatasetZa)
        self.windowAllDatasets.exec_()


    def filterAllDatasets(self):
        
        search_text = self.uiAllDatasets.searchBarFilter.text().strip().lower()


        # Parcourir les éléments du QListWidget
        for index in range(self.uiAllDatasets.datasetAllList.count()):
            item = self.uiAllDatasets.datasetAllList.item(index)
            item_text = item.text().lower()

            if self.uiAllDatasets.checkDisplayGeo.isChecked():
            # Vérifier si le texte de l'élément correspond à la recherche
                if not item.icon().isNull():
                    if search_text in item_text:
                        item.setHidden(False)
                    else:
                        item.setHidden(True)
            else:
                if search_text in item_text:
                    item.setHidden(False)
                else:
                    item.setHidden(True)


    def sortDatasetAz(self, state):
        if state == Qt.Checked:
            self.uiAllDatasets.datasetAllList.sortItems(Qt.AscendingOrder)
            self.uiAllDatasets.checkZa.setEnabled(False)
        else:
            self.filterDatasetviaCheckbox()
            self.uiAllDatasets.checkZa.setEnabled(True)


    def sortDatasetZa(self, state):
        if state == Qt.Checked:
            self.uiAllDatasets.datasetAllList.sortItems(Qt.DescendingOrder)
            self.uiAllDatasets.checkAz.setEnabled(False)
        else:
            self.filterDatasetviaCheckbox()
            self.uiAllDatasets.checkAz.setEnabled(True)

    def filterDatasetviaCheckbox(self):
        
        # Récupérez l'état de toutes les QCheckBox pour les thèmes
        selected_themes = [checkbox.text() for checkbox in self.uiAllDatasets.themes_checkboxes if checkbox.isChecked()]

        # Récupérez l'organisation sélectionnée
        selected_organizations = self.uiAllDatasets.comboBox.currentText()
        self.uiAllDatasets.dynamic_taglist = []

        # Récupérez l'état de toutes les QCheckBox pour les tags
        selected_tags = [checkbox.text() for checkbox in self.uiAllDatasets.tags_checkboxes if checkbox.isChecked()]

        if len(selected_themes) == 0 and len(selected_tags) == 0 and selected_organizations == "Choisir une organisation":
            self.uiAllDatasets.datasetAllList.clear()
            self.resetFilters()
            self.updateTagsCheckbox()
            return
        
        
        self.uiAllDatasets.datasetAllList.clear()
        
        for dataset in self.uiAllDatasets.alldatasets:
            nom = dataset[0]
            formats = dataset[1]
            tags = dataset[2]
            themes = dataset[3]
            organisation = dataset[4]
            
            hastheme = False
            for theme in selected_themes:
                if theme in themes:
                    hastheme = True
                    break

            hastag = True
            for tag in selected_tags:
                if tag not in tags:
                    hastag = False
                    break
            if hastag:
                for tag in tags:
                    self.uiAllDatasets.dynamic_taglist.append(tag)
                    
            
            hasorg = False
            if organisation == selected_organizations:
                hasorg = True
            
            if selected_themes == []:
                hastheme = True

            if selected_tags == []:
                hastag = True
                self.uiAllDatasets.dynamic_taglist = []

            if selected_organizations == "Choisir une organisation":
                hasorg = True

            if hastheme and hasorg and hastag:
                if "GeoJSON" in formats:
                    item = QtWidgets.QListWidgetItem(nom)
                    item.setIcon(self.geojson_icon)
                    item.setToolTip(nom)
                    self.uiAllDatasets.datasetAllList.addItem(item)
                else:
                    item = QtWidgets.QListWidgetItem(nom)
                    item.setToolTip(nom)
                    self.uiAllDatasets.datasetAllList.addItem(item)
        
        if self.uiAllDatasets.checkDisplayGeo.isChecked():
            self.filterNonGeo(Qt.Checked)
        else:
            self.filterNonGeo(Qt.Unchecked)
        
        self.updateTagsCheckbox()


    def updateTagsCheckbox(self):
        self.uiAllDatasets.dynamic_taglist = list(set(self.uiAllDatasets.dynamic_taglist))
        #check if 0 tags are checked
        if self.uiAllDatasets.dynamic_taglist == []:
            for checkbox in self.uiAllDatasets.tags_checkboxes:
                checkbox.setHidden(False)
            return
        for checkbox in self.uiAllDatasets.tags_checkboxes:
            if checkbox.text() not in self.uiAllDatasets.dynamic_taglist:
                checkbox.setHidden(True)
            else:
                checkbox.setHidden(False)
            

    def resetFilters(self):
        for checkbox in self.uiAllDatasets.themes_checkboxes + self.uiAllDatasets.tags_checkboxes:
            checkbox.setChecked(False)
        for i in range(len(self.Alldatasetlist)):
            if "GeoJSON" in self.Alldatasetlist[i][1]:
                item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
                item.setIcon(self.geojson_icon)
                item.setToolTip(self.Alldatasetlist[i][0])
                self.uiAllDatasets.datasetAllList.addItem(item)
            # elif "CSV" in self.Alldatasetlist[i][1]:
            #     item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
            #     item.setForeground(Qt.green)
            #     self.uiAllDatasets.datasetAllList.addItem(item)
            # elif "JSON" in self.Alldatasetlist[i][1]:
            #     item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
            #     item.setForeground(Qt.yellow)
            #     self.uiAllDatasets.datasetAllList.addItem(item)
            else:
                item = QtWidgets.QListWidgetItem(self.Alldatasetlist[i][0])
                item.setToolTip(self.Alldatasetlist[i][0])
                self.uiAllDatasets.datasetAllList.addItem(item)
            
        if self.uiAllDatasets.checkDisplayGeo.isChecked():
            self.filterNonGeo(Qt.Checked)
        else:
            self.filterNonGeo(Qt.Unchecked)


    def filterNonGeo(self, state):
        
        if state == Qt.Checked:

            for row in range(self.uiAllDatasets.datasetAllList.count()):
                item = self.uiAllDatasets.datasetAllList.item(row)
                if item is not None:
                    # Vérifiez si l'élément a une icône
                    if item.icon().isNull():
                        item.setHidden(True)
        else : 
            for row in range(self.uiAllDatasets.datasetAllList.count()):
                item = self.uiAllDatasets.datasetAllList.item(row)
                if item is not None:
                    item.setHidden(False)


    def getD4CdatasetsfromAll(self, dataset_name):
        #find the dataset name with the dataset title
        for dataset in self.Alldatasetlist:
            if dataset_name == dataset[0]:
                dataset_name = dataset[5]
                break
        self.dlg.datasetId.setText(dataset_name)
        self.dlg.exportLine.setText(dataset_name)
        self.getD4Cdatasets()
        self.windowAllDatasets.close()


    def turnOffAllDatasetLoaded(self):
        self.isAlldatasetsLoaded = False

    
    def updateHistoryPush(self):
        selected_items = self.dlg.historyList.selectedItems()
        if len(selected_items) > 0:
            self.dlg.pushHistory.setEnabled(True)
        else:
            self.dlg.pushHistory.setEnabled(False)

    
    def updateFilesPush(self):
        selected_items = self.dlg.filesList.selectedItems()
        if len(selected_items) > 0:
            self.dlg.pushLoadHistoryfile.setEnabled(True)
        else:
            self.dlg.pushLoadHistoryfile.setEnabled(False)


    def currentSiteIndex(self):

        sites_file_path = os.path.join(os.path.expanduser("~"), '.d4cplugin', 'sites.json')
        with open(sites_file_path, 'r') as json_file:
            site_data = json.load(json_file)

        sites = site_data["saved_sites"]["sites"]
        for i in range(len(sites)):
            if sites[i]["site_url"] == self.sit and sites[i]["username"] == self.usr:
                return i
            
        return 0


    def updatePrevisu(self):
        
        selected_resource = self.dlg.resourcesList.currentItem()

        if selected_resource:
            self.dlg.tableWidget.clear()
            selected_resource = selected_resource.text()
            if not(selected_resource.endswith('.csv')):
                
                self.dlg.tableWidget.setRowCount(1)
                self.dlg.tableWidget.setColumnCount(1)
                self.dlg.tableWidget.setItem(0, 0, QtWidgets.QTableWidgetItem('Aperçu non disponible pour les fichiers non CSV'))
                return
            selected_resource_id = self.listExistingResourceById[selected_resource]
            url = self.sit + '/d4c/api/records/2.0/search/?resource_id=' + selected_resource_id

            try:
                response = requests.get(url)

                if response.status_code == 200:
                    data = response.json()
                    if data['success'] == False:
                        return
                    
                    

            except requests.exceptions.RequestException as e:
                # Gestion des erreurs de requête
                self.show_error_message(f"Request error : {e}")

            except requests.exceptions.HTTPError as e:
                # Gestion des erreurs HTTP (erreurs 4xx et 5xx)
                self.show_error_message(f"HTTP error : {e.response.status_code}")

            except requests.exceptions.ConnectionError as e:
                # Gestion des erreurs de connexion
                self.show_error_message(f"Connection error : {e}")

            except requests.exceptions.Timeout as e:
                # Gestion des erreurs de délai d'attente
                self.show_error_message(f"Expired request : : {e}")

            except requests.exceptions.TooManyRedirects as e:
                # Gestion des erreurs de redirections excessives
                self.show_error_message(f"Too many redirects ! : : {e}")

            except requests.exceptions.RequestException as e:
                # Gestion générale des exceptions de requête
                self.show_error_message(f"Request error : {e}")

            except Exception as e:
                # Gestion d'autres exceptions non spécifiques
                self.show_error_message(f"Unhandled error occured: {e}") 

            datas = data['result']['records']
            headers = []
            for key in list(datas[0].keys()):
                headers.append(key)
            nb_col = len(headers)
            nb_rows = data['result']['total']
            if nb_rows > 100:
                nb_rows = 100
            self.dlg.tableWidget.setRowCount(nb_rows)
            self.dlg.tableWidget.setColumnCount(nb_col)
            self.dlg.tableWidget.setHorizontalHeaderLabels(headers)

            for i in range(nb_rows):
                for j in range(nb_col):
                    self.dlg.tableWidget.setItem(i, j, QtWidgets.QTableWidgetItem(str(datas[i][headers[j]])))


    def openTableWindow(self):
        self.windowTable = TableWindow()


        self.windowTable.table.setColumnCount(self.dlg.tableWidget.columnCount())
        self.windowTable.table.setRowCount(self.dlg.tableWidget.rowCount())
        self.windowTable.table.setHorizontalHeaderLabels(self.dlg.tableWidget.horizontalHeaderItem(i).text() for i in range(self.dlg.tableWidget.columnCount()))
        for row in range(self.dlg.tableWidget.rowCount()):
            for col in range(self.dlg.tableWidget.columnCount()):
                item = self.dlg.tableWidget.item(row, col)
                if item is not None:
                    new_item = QtWidgets.QTableWidgetItem(item.text())  
                    self.windowTable.table.setItem(row, col, new_item)
        self.windowTable.show()


    def openAbout(self):
        self.windowAbout = QtWidgets.QDialog()
        self.uiAbout = Ui_pluginInfos()
        self.uiAbout.setupUi(self.windowAbout)
        self.windowAbout.exec_()


    def openHelp(self):
        os.system("start \"\" https://wikijs.data4citizen.com/")


    def changeLanguage(self):
        language_code = self.dlg.languageBox.currentIndex()
        if language_code == 0:
            lang = 'fr'
        else:
            lang = 'en'
        
        destination_folder = os.path.expanduser('~/.d4cplugin')  # Modifier le chemin selon vos besoins
        json_file_path = os.path.join(destination_folder, 'logs.json')

        with open(json_file_path, 'r') as json_file:
            data = json.load(json_file)
            data["lang"] = lang
        with open(json_file_path, 'w') as json_file:
            json.dump(data, json_file, indent=4)
        if lang == 'fr':
            self.show_info_message('Veuillez redémarrer QGIS pour appliquer les changements')
            # Quitter le plugin
            self.dlg.close()
            
        else: 
            self.show_info_message('Please restart QGIS to apply changes')
            # Quitter le plugin
            self.dlg.close()
            